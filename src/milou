#!/bin/bash
# Relax strict mode temporarily for performance testing


# =============================================================================
# Milou CLI - Main Entry Point
# Professional command-line interface with intelligent state detection
# Version: 4.0.0 - Smart State-Based Architecture
# =============================================================================

VERSION="4.0.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SRC_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# =============================================================================
# GLOBAL SETUP AND UTILITIES
# =============================================================================

# Global variables (colors are declared in _core.sh)
export VERBOSE=${VERBOSE:-false}
export DEBUG=${DEBUG:-false}
export INTERACTIVE=${INTERACTIVE:-true}
export FORCE=${FORCE:-false}
export ASSUME_YES=${ASSUME_YES:-false}

# Trap for cleanup

# =============================================================================
# ERROR HANDLING AND CLEANUP
# =============================================================================

function backtrace() {
    local depth=${#FUNCNAME[@]}
    
    for ((i=1; i<depth; i++)); do
        local func="${FUNCNAME[$i]}"
        local line="${BASH_LINENO[$((i-1))]}"
        local src="${BASH_SOURCE[$((i-1))]}"
        >&2 printf '%*s' "$i" ''
        >&2 echo -e "at: ${UNDERLINE:-}$func()${NC:-}, $src, line $line"
    done
}

function cleanup() {
    local status_code=$1
    
    if [[ "${EXITMSG:-}" != "" ]]; then
        if [[ "$status_code" -ne 0 ]]; then
            echo -e "${RED:-}ERROR: ${EXITMSG}${NC:-}" >&2
        else
            echo -e "${GREEN:-}${EXITMSG}${NC:-}" >&2
        fi
    fi
    
    if [[ "$status_code" -ne 0 && "${VERBOSE:-false}" == "true" ]]; then
        echo -e "${RED:-}${DIM:-}Stack trace:${NC:-}" >&2
        backtrace
    fi
    
    if [[ "$status_code" -ne 0 && "${VERBOSE:-false}" == "false" ]]; then
        echo -e "${DIM:-}Try running with '-v' for verbose output${NC:-}" >&2
    fi
    
    trap - EXIT
    exit $status_code
}

# =============================================================================
# SIMPLIFIED MODULE LOADING
# =============================================================================

function load_core_modules() {
    # Direct module loading - no complex tracking needed
    source "${SRC_DIR}/_core.sh" || exit 1
    source "${SRC_DIR}/_state.sh" || exit 1  
    source "${SRC_DIR}/_validation.sh" || exit 1
    
    # Load error recovery for safety
    source "${SRC_DIR}/_error_recovery.sh" || exit 1
    
    # Load modules on-demand in command handlers
}

# =============================================================================
# SMART CONTEXTUAL INTERFACE
# =============================================================================

function show_smart_header() {
    local current_state="${1:-unknown}"
    
    if tty -s && [[ "${QUIET:-false}" != "true" ]]; then
        echo -e "${BOLD}${PURPLE}"
        cat << 'EOF'

    ‚ñà‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó‚ñà‚ñà‚ïó      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó
    ‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  
    ‚ñà‚ñà‚ïî‚ñà‚ñà‚ñà‚ñà‚ïî‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  
    ‚ñà‚ñà‚ïë‚ïö‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë     ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë  
    ‚ñà‚ñà‚ïë ‚ïö‚ïê‚ïù ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù  
    ‚ïö‚ïê‚ïù     ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù   
    
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   Professional Docker Management        ‚îÇ
    ‚îÇ   üöÄ Simple ‚Ä¢ Secure ‚Ä¢ Reliable        ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

EOF
        echo -e "${NC}"
        echo -e "${BOLD}${CYAN}Milou CLI - Professional Docker Management v$VERSION${NC}"
        
        # Show contextual status
        if [[ "$current_state" != "unknown" ]]; then
            echo -e "${DIM}Current state: $(describe_installation_state "$current_state")${NC}"
        fi
        echo
    fi
}

function show_contextual_help() {
    local current_state="${1:-unknown}"
    
    echo -e "${BOLD}${GREEN}Milou CLI - Intelligent Container Management${NC}"
    echo
    
    # Show state-specific help
    case "$current_state" in
        "fresh")
            echo -e "${CYAN}üÜï Fresh System Detected${NC}"
            echo "You're ready to install Milou! Here's what you can do:"
            echo
            echo -e "${BOLD}Getting Started:${NC}"
            echo "  setup                           Install Milou on this system"
            echo "  setup --help                    See all installation options"
            echo
            echo -e "${BOLD}System Information:${NC}"
            echo "  status                          Check system requirements"
            echo "  --version                       Show version information"
            ;;
        "running")
            echo -e "${GREEN}‚úÖ Milou is Running${NC}"
            echo "Your Milou system is up and running! Here's what you can do:"
            echo
            echo -e "${BOLD}System Management:${NC}"
            echo "  status                          Show detailed system status"
            echo "  version                         Show comprehensive version info"
            echo "  update-status                   Check for available updates"
            echo "  logs [service]                  View service logs"
            echo "  backup [type]                   Create backup"
            echo "  update                          Check for and install updates"
            echo
            echo -e "${BOLD}Service Control:${NC}"
            echo "  restart                         Restart all services"
            echo "  stop                            Stop all services"
            echo
            echo -e "${BOLD}Administration:${NC}"
            echo "  admin credentials               Manage admin credentials"
            echo "  config show                     Show current configuration"
            echo "  shell <service>                 Access service shell"
            ;;
        "installed_stopped")
            echo -e "${YELLOW}‚è∏Ô∏è  Milou is Stopped${NC}"
            echo "Milou is installed but not running. Here's what you can do:"
            echo
            echo -e "${BOLD}Start Services:${NC}"
            echo "  start                           Start all Milou services"
            echo "  logs [service]                  Check why services stopped"
            echo
            echo -e "${BOLD}Maintenance:${NC}"
            echo "  status                          Diagnose system issues"
            echo "  version                         Show system version info"
            echo "  update-status                   Check for available updates"
            echo "  update                          Update before starting"
            echo "  backup                          Backup data before changes"
            echo
            echo -e "${BOLD}Troubleshooting:${NC}"
            echo "  setup --repair                  Fix configuration issues"
            echo "  recovery validate               Check system integrity"
            echo "  recovery restore <id>           Restore from snapshot"
            ;;
        "broken")
            echo -e "${RED}üîß Broken Installation Detected${NC}"
            echo "Your Milou installation needs attention. Here's how to fix it:"
            echo
            echo -e "${BOLD}Repair Options:${NC}"
            echo "  setup --repair                  Attempt to repair installation"
            echo "  setup --force                   Reinstall (‚ö†Ô∏è  may lose data)"
            echo "  restore <backup>                Restore from backup"
            echo "  recovery list                   Show available snapshots"
            echo "  recovery restore <id>           Restore from system snapshot"
            echo
            echo -e "${BOLD}Diagnosis:${NC}"
            echo "  status                          Show detailed system status"
            echo "  version                         Show system version info"
            echo "  logs                           Check error logs"
            ;;
        *)
            echo -e "${BOLD}Usage:${NC}"
            echo "  milou <command> [options]"
            echo
            echo -e "${BOLD}Main Commands:${NC}"
            echo "  setup                           Install or configure Milou"
            echo "  status                          Show system status"
            echo "  version                         Show comprehensive version info"
            echo "  update-status                   Check for available updates"
            echo "  start/stop/restart              Control services"
            echo "  update                          Update system"
            echo "  backup/restore                  Data management"
            echo "  recovery                        System recovery and snapshots"
            ;;
    esac
    
    echo
    echo -e "${BOLD}Global Options:${NC}"
    echo "  -h, --help                      Show this help message"
    echo "  -v, --verbose                   Enable verbose output"
    echo "  -d, --debug                     Enable debug mode"
    echo "  -y, --yes                       Assume yes to all prompts"
    echo "  -f, --force                     Force operations (use with caution)"
    echo "  --version                       Show version information"
    echo
    
    # Show state-specific recommendations
    local recommendations
    recommendations=$(get_recommended_actions "$current_state")
    if [[ -n "$recommendations" ]]; then
        echo -e "${BOLD}üí° Recommended next step:${NC}"
        echo "  $recommendations"
        echo
    fi
}

function show_version() {
    # If update module is available, show comprehensive version info
    if command -v handle_version >/dev/null 2>&1; then
        handle_version
    else
        # Fallback to basic version display
        echo "Milou CLI v$VERSION"
        echo "Professional Docker Management Tool"
        if [[ "${VERBOSE:-false}" == "true" ]]; then
            echo "Script Directory: $SCRIPT_DIR"
            echo "Architecture: State-based with unified validation"
            echo "Environment: $(uname -a)"
            
            # Show installation state if available
            if command -v get_current_state >/dev/null 2>&1; then
                local state
                state=$(get_current_state "true")
                echo "Installation State: $state"
            fi
        fi
    fi
}

# =============================================================================
# SMART COMMAND HANDLERS
# =============================================================================

function handle_smart_setup() {
    source "${SRC_DIR}/_setup.sh" || exit 1
    
    # Show analysis message BEFORE starting analysis
    echo -e "${CYAN}üîç Analyzing your system...${NC}"
    
    # Get current installation state (quiet mode to avoid output corruption)
    local current_state
    current_state=$(get_current_state "true")
    
    # Determine setup mode based on state (quiet mode to avoid output corruption)
    local setup_mode
    setup_mode=$(smart_setup_mode "$current_state" "$FORCE" "true")
    
    # Override for repair mode if specified
    for arg in "$@"; do
        if [[ "$arg" == "--repair" ]]; then
            setup_mode="repair"
            break
        fi
    done
    
    echo "Installation state: $(describe_installation_state "$current_state")"
    echo "Setup mode: $setup_mode"
    echo
    
    # Create a safe wrapper function for setup operations
    run_setup_safely() {
        case "$setup_mode" in
            "install")
                echo -e "${GREEN}üÜï Fresh Installation${NC}"
                echo "This will install Milou with optimal defaults for your system."
                if command -v handle_setup_modular >/dev/null 2>&1; then
                    handle_setup_modular "$@"
                else
                    echo -e "${RED}ERROR: Setup module not properly loaded${NC}" >&2
                    exit 1
                fi
                ;;
            "update_check")
                echo -e "${BLUE}üîÑ Existing Installation Detected${NC}"
                echo -e "${GREEN}üîí DATA SAFETY: Your existing credentials and data will be preserved automatically!${NC}"
                echo ""
                echo "Milou detected an existing installation. Here are your options:"
                echo ""
                
                if [[ "${INTERACTIVE:-true}" == "true" ]]; then
                    echo "1. üîÑ Update system (preserves all data - recommended)"
                    echo "2. üíæ Create backup first (extra safety)"
                    echo "3. üìä Check system status"
                    echo "4. üÜï Generate new credentials (‚ö†Ô∏è  may affect data access)"
                    echo "5. üí• Force clean reinstall (‚ö†Ô∏è  destroys all data)"
                    echo
                    read -p "What would you like to do? [1]: " choice
                    choice=${choice:-1}
                    
                    case "$choice" in
                        1) 
                            echo -e "${GREEN}‚úÖ Smart choice! Updating with data preservation...${NC}"
                            echo ""
                            handle_setup_modular --preserve-creds "$@"
                            ;;
                        2)
                            echo -e "${BLUE}üì¶ Creating backup for extra safety...${NC}"
                            source "${SRC_DIR}/_backup.sh" || exit 1
                            if command -v handle_backup >/dev/null 2>&1; then
                                handle_backup "full"
                                echo -e "${GREEN}‚úÖ Backup completed! Now running safe update...${NC}"
                                handle_setup_modular --preserve-creds "$@"
                            else
                                echo "Backup module not available - running safe update anyway"
                                handle_setup_modular --preserve-creds "$@"
                            fi
                            ;;
                        3)
                            handle_smart_status "$@"
                            ;;
                        4)
                            echo -e "${YELLOW}‚ö†Ô∏è  WARNING: New credentials may affect data access!${NC}"
                            echo "Your existing database and encrypted data may become inaccessible."
                            echo ""
                            read -p "Are you sure you want new credentials? [y/N]: " confirm
                            if [[ "${confirm,,}" =~ ^(y|yes)$ ]]; then
                                echo -e "${YELLOW}üîë Generating new credentials (data access may be affected)...${NC}"
                                handle_setup_modular --force-new-creds "$@"
                            else
                                echo -e "${GREEN}‚úÖ Wise choice! Running safe update instead...${NC}"
                                handle_setup_modular --preserve-creds "$@"
                            fi
                            ;;
                        5)
                            echo -e "${RED}üí• DANGER: This will destroy ALL your data!${NC}"
                            echo "This cannot be undone!"
                            echo ""
                            read -p "Type 'DESTROY DATA' to confirm: " confirm
                            if [[ "$confirm" == "DESTROY DATA" ]]; then
                                FORCE=true
                                handle_setup_modular --force --clean "$@"
                            else
                                echo -e "${GREEN}‚úÖ Operation cancelled - running safe update instead...${NC}"
                                handle_setup_modular --preserve-creds "$@"
                            fi
                            ;;
                        *)
                            echo -e "${YELLOW}Invalid choice. Defaulting to safe update...${NC}"
                            handle_setup_modular --preserve-creds "$@"
                            ;;
                    esac
                else
                    # Non-interactive mode: default to safe credential preservation
                    echo -e "${GREEN}ü§ñ Non-interactive mode: Automatically preserving credentials (safe default)${NC}"
                    handle_setup_modular --preserve-creds "$@"
                fi
                ;;
            "repair")
                echo -e "${YELLOW}üõ†Ô∏è  Repairing Installation${NC}"
                echo -e "${GREEN}üîí Preserving your existing credentials during repair...${NC}"
                echo ""
                if command -v handle_setup_modular >/dev/null 2>&1; then
                    handle_setup_modular --repair "$@"
                else
                    echo -e "${RED}ERROR: Setup module not properly loaded${NC}" >&2
                    exit 1
                fi
                ;;
            "start"|"resume")
                echo -e "${YELLOW}‚ñ∂Ô∏è  Resuming Services${NC}"
                echo "Starting your existing Milou installation."
                
                # Check if we have the required GitHub token for private images
                local github_token="${GITHUB_TOKEN:-}"
                if [[ -z "$github_token" && -f "${SCRIPT_DIR}/.env" ]]; then
                    # Try to load token from existing config
                    source "${SCRIPT_DIR}/.env" 2>/dev/null || true
                    github_token="${GITHUB_TOKEN:-}"
                fi
                
                # Parse token from command line if provided
                local skip_next=false
                for arg in "$@"; do
                    if [[ "$skip_next" == "true" ]]; then
                        github_token="$arg"
                        skip_next=false
                        break
                    fi
                    
                    case "$arg" in
                        --token)
                            skip_next=true
                            ;;
                        --token=*)
                            github_token="${arg#--token=}"
                            break
                            ;;
                    esac
                done
                
                # If still no token, handle appropriately
                if [[ -z "$github_token" ]]; then
                    echo ""
                    echo -e "${RED}‚ùå GitHub Authentication Required${NC}"
                    echo "Milou uses private Docker images that require authentication."
                    echo ""
                    
                    # Interactive prompt for token if in interactive mode
                    if [[ "${INTERACTIVE:-true}" == "true" && -t 0 && -t 1 ]]; then
                        echo -e "${BOLD}${CYAN}üîë GitHub Token Setup${NC}"
                        echo "Please provide your GitHub Personal Access Token:"
                        echo ""
                        echo -e "${DIM}How to get a token: https://github.com/settings/tokens${NC}"
                        echo -e "${DIM}Required scope: 'read:packages'${NC}"
                        echo ""
                        
                        echo -ne "${CYAN}GitHub Token (ghp_...): ${NC}"
                        read -r github_token
                        
                        if [[ -z "$github_token" ]]; then
                            echo -e "${RED}‚ùå No token provided. Cannot continue without authentication.${NC}"
                            return 1
                        fi
                        
                        # Validate token format
                        if [[ ! "$github_token" =~ ^gh[ps]_[A-Za-z0-9]{36}$ ]] && [[ ! "$github_token" =~ ^github_pat_[A-Za-z0-9_]{22,}$ ]]; then
                            echo -e "${YELLOW}‚ö†Ô∏è  Warning: Token format doesn't match expected GitHub token format${NC}"
                            echo -e "${YELLOW}Proceeding anyway - Docker will validate the token${NC}"
                        fi
                        
                        # Save token to .env file for future use
                        if [[ -f "${SCRIPT_DIR}/.env" ]]; then
                            # Update existing .env file
                            if grep -q "^GITHUB_TOKEN=" "${SCRIPT_DIR}/.env"; then
                                sed -i "s/^GITHUB_TOKEN=.*/GITHUB_TOKEN=$github_token/" "${SCRIPT_DIR}/.env"
                            else
                                echo "GITHUB_TOKEN=$github_token" >> "${SCRIPT_DIR}/.env"
                            fi
                            echo -e "${GREEN}‚úì Token saved to .env file for future use${NC}"
                        fi
                        
                        # Export for current session
                        export GITHUB_TOKEN="$github_token"
                        echo -e "${GREEN}‚úì GitHub token configured${NC}"
                        echo ""
                    else
                        # Non-interactive mode - show instructions and exit
                        echo -e "${BOLD}${CYAN}üîë How to get a GitHub token:${NC}"
                        echo "1. Visit: https://github.com/settings/tokens"
                        echo "2. Create a token with 'read:packages' scope"
                        echo "3. Use one of these options:"
                        echo ""
                        echo -e "${GREEN}Option 1: Add to your .env file${NC}"
                        echo "  echo 'GITHUB_TOKEN=ghp_your_token_here' >> .env"
                        echo ""
                        echo -e "${GREEN}Option 2: Use command line${NC}"
                        echo "  ./milou.sh setup --token ghp_your_token_here"
                        echo ""
                        echo -e "${GREEN}Option 3: Set environment variable${NC}"
                        echo "  export GITHUB_TOKEN=ghp_your_token_here"
                        echo "  ./milou.sh setup"
                        echo ""
                        return 1
                    fi
                else
                    # Export the token for Docker operations
                    export GITHUB_TOKEN="$github_token"
                    echo -e "${GREEN}‚úì Using GitHub token for authentication${NC}"
                fi
                
                # Filter out setup-specific arguments before passing to Docker
                local docker_args=()
                local skip_next=false
                for arg in "$@"; do
                    if [[ "$skip_next" == "true" ]]; then
                        skip_next=false
                        continue
                    fi
                    
                    case "$arg" in
                        --token)
                            # Skip this argument and the next one (the token value)
                            skip_next=true
                            ;;
                        --token=*)
                            # Skip this argument (token with value)
                            ;;
                        --preserve-creds|--new-creds|--force-new-creds|--clean|--automated|--interactive|--smart|--skip-validation|--dev|--development)
                            # Skip setup-specific arguments
                            ;;
                        *)
                            docker_args+=("$arg")
                            ;;
                    esac
                done
                
                # Use enhanced start command with validation
                if command -v service_start_with_validation >/dev/null 2>&1; then
                    service_start_with_validation "" "60" "false"
                else
                    handle_docker_command "start" "${docker_args[@]}"
                fi
                ;;
            "reconfigure")
                echo -e "${BLUE}üîß Reconfiguring System${NC}"
                echo -e "${GREEN}üîí Preserving your existing credentials and data...${NC}"
                handle_setup_modular --preserve-creds "$@"
                ;;
            "reinstall")
                echo -e "${RED}üîÑ Force Reinstall${NC}"
                echo "‚ö†Ô∏è  This will destroy all existing data!"
                handle_setup_modular --force --clean "$@"
                ;;
            *)
                echo -e "${RED}ERROR: Unknown setup mode: $setup_mode${NC}" >&2
                exit 1
                ;;
        esac
    }
    
    # Execute setup with automatic rollback on failure
    # safe_operation "milou_setup_$setup_mode" "run_setup_safely" "$@"
    run_setup_safely "$@"
}

function handle_smart_status() {
    source "${SRC_DIR}/_docker.sh" || exit 1
    
    # Get current installation state (quiet mode to avoid output corruption)
    local current_state
    current_state=$(get_current_state "true")
    
    echo -e "${CYAN}üìä Milou System Status${NC}"
    echo "=================="
    echo
    echo "Installation State: $(describe_installation_state "$current_state")"
    echo
    
    case "$current_state" in
        "fresh")
            echo -e "${BLUE}System Analysis:${NC}"
            echo "‚Ä¢ No Milou installation detected"
            echo "‚Ä¢ Ready for fresh installation"
            echo
            echo -e "${GREEN}Next Steps:${NC}"
            echo "‚Ä¢ Run: milou setup"
            ;;
        "running")
            echo -e "${GREEN}‚úÖ Services Status:${NC}"
            if command -v docker_status >/dev/null 2>&1; then
                docker_status "$@"
            else
                docker compose ps 2>/dev/null || echo "Could not get service status"
            fi
            ;;
        "installed_stopped")
            echo -e "${YELLOW}‚è∏Ô∏è  Services Stopped:${NC}"
            if command -v docker_status >/dev/null 2>&1; then
                docker_status "$@"
            else
                docker compose ps 2>/dev/null || echo "Could not get service status"
            fi
            echo
            echo -e "${GREEN}Next Steps:${NC}"
            echo "‚Ä¢ Run: milou start"
            echo "‚Ä¢ Run: milou logs (to check why stopped)"
            ;;
        "broken")
            echo -e "${RED}üîß System Issues Detected:${NC}"
            if command -v docker_status >/dev/null 2>&1; then
                docker_status "$@"
            else
                echo "Cannot determine service status"
            fi
            echo
            echo -e "${GREEN}Repair Options:${NC}"
            echo "‚Ä¢ Run: milou setup --repair"
            echo "‚Ä¢ Run: milou logs (to diagnose issues)"
            ;;
        *)
            echo -e "${YELLOW}System state: $current_state${NC}"
            if command -v docker_status >/dev/null 2>&1; then
                docker_status "$@"
            else
                echo "Run 'milou setup' to initialize the system"
            fi
            ;;
    esac
    
    # Add update check for running or stopped services
    if [[ "$current_state" == "running" || "$current_state" == "installed_stopped" ]]; then
        _check_status_updates
    fi
}

# Simple update checker for status command
_check_status_updates() {
    echo
    echo -e "${CYAN}üì¶ Update Status${NC}"
    echo "==============="
    
    # Check if we have a GitHub token
    local github_token="${GITHUB_TOKEN:-}"
    if [[ -z "$github_token" && -f "${SCRIPT_DIR}/.env" ]]; then
        github_token=$(grep "^GITHUB_TOKEN=" "${SCRIPT_DIR}/.env" 2>/dev/null | cut -d'=' -f2- | tr -d '"'"'" || echo "")
    fi
    
    if [[ -z "$github_token" ]]; then
        echo "‚ö†Ô∏è  No GitHub token available for update check"
        echo "üí° Set GITHUB_TOKEN in .env file to enable update checks"
        return 0
    fi
    
    # Quick validation of token format
    if [[ ! "$github_token" =~ ^gh[ps]_[A-Za-z0-9]{36}$ ]] && [[ ! "$github_token" =~ ^github_pat_[A-Za-z0-9_]{22,}$ ]]; then
        echo "‚ö†Ô∏è  Invalid GitHub token format"
        echo "üí° Update GITHUB_TOKEN in .env file with a valid token"
        return 0
    fi
    
    # Try to load update module silently
    if ! source "${SRC_DIR}/_update.sh" 2>/dev/null; then
        echo "‚ö†Ô∏è  Update checking not available"
        return 0
    fi
    
    # Check if we have any containers to check
    local has_containers=false
    if docker ps -a --filter "name=milou-" --format "{{.Names}}" 2>/dev/null | grep -q "milou-"; then
        has_containers=true
    fi
    
    if [[ "$has_containers" == "false" ]]; then
        echo "‚ÑπÔ∏è  No Milou containers found to check for updates"
        echo "üí° Run 'milou setup' to install services first"
        return 0
    fi
    
    # Run a silent update check
    echo "üîç Checking for updates..."
    
    # Capture all output and only show clean results
    local temp_file=$(mktemp)
    local check_result=0
    
    # Run the check and capture exit code
    if command -v check_updates_needed >/dev/null 2>&1; then
        check_updates_needed "latest" "$github_token" "false" "true" >"$temp_file" 2>&1 || check_result=$?
    else
        echo "‚ö†Ô∏è  Update checking function not available" > "$temp_file"
        check_result=1
    fi
    
    # Clean up temp file
    rm -f "$temp_file" 2>/dev/null
    
    # Show results based on exit code and environment variables
    if [[ $check_result -eq 0 ]]; then
        # Updates are available
        local services_to_update="${MILOU_SERVICES_TO_UPDATE:-}"
        if [[ -n "$services_to_update" ]]; then
            echo -e "${YELLOW}‚¨ÜÔ∏è  Updates Available:${NC}"
            IFS=' ' read -ra update_array <<< "$services_to_update"
            for service in "${update_array[@]}"; do
                local current_var="RUNNING_VERSION_${service^^}"
                local target_var="MILOU_TARGET_VERSION_${service^^}"
                local current_version="${!current_var:-unknown}"
                local target_version="${!target_var:-latest}"
                if [[ "$current_version" == "unknown" ]]; then
                    echo "  üì¶ $service: Install v$target_version"
                else
                    echo "  üì¶ $service: v$current_version ‚Üí v$target_version"
                fi
            done
            echo
            echo -e "${GREEN}üí° Run: milou update${NC}"
        else
            echo "‚úÖ All services are up to date"
        fi
    else
        # No updates needed or API failed
        echo "‚úÖ All services appear to be up to date"
        echo "üí° Run 'milou update-status' for detailed information"
    fi
}

# =============================================================================
# EXISTING COMMAND HANDLERS (Updated)
# =============================================================================

function handle_status_command() {
    handle_smart_status "$@"
}

function handle_docker_command() {
    source "${SRC_DIR}/_docker.sh" || exit 1
    local subcommand="${1:-help}"
    shift 2>/dev/null || true
    
    case "$subcommand" in
        start|up)
            docker_execute "up" "" "false" "$@"
            clear_state_cache  # Clear cache after state change
            ;;
        stop|down)
            docker_execute "down" "" "false" "$@"
            clear_state_cache  # Clear cache after state change
            ;;
        restart)
            docker_execute "restart" "" "false" "$@"
            clear_state_cache  # Clear cache after state change
            ;;
        logs)
            docker_execute "logs" "" "false" "$@"
            ;;
        health)
            if command -v health_check_all >/dev/null 2>&1; then
                health_check_all "$@"
            else
                # Fallback to original function
                handle_docker_command "health" "$@"
            fi
            ;;
        shell)
            docker_execute "exec" "milou-backend" "false" "/bin/bash" "$@"
            ;;
        *)
            echo -e "${YELLOW}Available docker commands:${NC}"
            echo "  start     - Start all services"
            echo "  stop      - Stop all services"
            echo "  restart   - Restart all services"
            echo "  logs      - View service logs"
            echo "  health    - Run health checks"
            echo "  shell     - Access service shell"
            ;;
    esac
}

# ... existing handlers remain the same but with state cache clearing where appropriate ...
function handle_backup_command() {
    source "${SRC_DIR}/_backup.sh" || exit 1
    if command -v handle_backup >/dev/null 2>&1; then
        handle_backup "$@"
    else
        echo -e "${RED}ERROR: Backup module not properly loaded${NC}" >&2
        exit 1
    fi
}

function handle_restore_command() {
    source "${SRC_DIR}/_backup.sh" || exit 1
    if command -v handle_restore >/dev/null 2>&1; then
        handle_restore "$@"
        clear_state_cache  # Clear cache after state change
    else
        echo -e "${RED}ERROR: Backup module not properly loaded${NC}" >&2
        exit 1
    fi
}

function handle_update_command() {
    source "${SRC_DIR}/_update.sh" || exit 1
    if command -v handle_update >/dev/null 2>&1; then
        handle_update "$@"
        clear_state_cache  # Clear cache after state change
    else
        echo -e "${RED}ERROR: Update module not properly loaded${NC}" >&2
        exit 1
    fi
}

function handle_admin_command() {
    source "${SRC_DIR}/_admin.sh" || exit 1
    if command -v handle_admin >/dev/null 2>&1; then
        handle_admin "$@"
    else
        echo -e "${RED}ERROR: Admin module not properly loaded${NC}" >&2
        exit 1
    fi
}

function handle_config_command() {
    source "${SRC_DIR}/_config.sh" || exit 1
    local subcommand="${1:-show}"
    shift 2>/dev/null || true
    
    case "$subcommand" in
        show|display)
            if command -v config_show >/dev/null 2>&1; then
                config_show "$@"
            else
                echo -e "${RED}ERROR: Config show function not available${NC}" >&2
                exit 1
            fi
            ;;
        validate)
            if command -v config_validate >/dev/null 2>&1; then
                config_validate "$@"
            else
                echo -e "${RED}ERROR: Config validate function not available${NC}" >&2
                exit 1
            fi
            ;;
        generate)
            if command -v config_generate >/dev/null 2>&1; then
                config_generate "$@"
                clear_state_cache  # Clear cache after state change
            else
                echo -e "${RED}ERROR: Config generate function not available${NC}" >&2
                exit 1
            fi
            ;;
        *)
            echo -e "${YELLOW}Available config commands:${NC}"
            echo "  show       - Display current configuration"
            echo "  validate   - Validate configuration"
            echo "  generate   - Generate new configuration"
            ;;
    esac
}

function handle_user_command() {
    source "${SRC_DIR}/_user.sh" || exit 1
    local subcommand="${1:-help}"
    shift 2>/dev/null || true
    
    case "$subcommand" in
        create)
            if command -v user_create >/dev/null 2>&1; then
                user_create "$@"
            else
                echo -e "${RED}ERROR: User create function not available${NC}" >&2
                exit 1
            fi
            ;;
        switch)
            if command -v user_switch >/dev/null 2>&1; then
                user_switch "$@"
            else
                echo -e "${RED}ERROR: User switch function not available${NC}" >&2
                exit 1
            fi
            ;;
        docker)
            if command -v user_setup_docker_permissions >/dev/null 2>&1; then
                user_setup_docker_permissions "$@"
            else
                echo -e "${RED}ERROR: User docker function not available${NC}" >&2
                exit 1
            fi
            ;;
        *)
            echo -e "${YELLOW}Available user commands:${NC}"
            echo "  create     - Create new user"
            echo "  switch     - Switch to different user"
            echo "  docker     - Setup Docker permissions"
            ;;
    esac
}

function handle_ssl_command() {
    source "${SRC_DIR}/_ssl.sh" || exit 1
    local subcommand="${1:-status}"
    shift 2>/dev/null || true
    
    case "$subcommand" in
        status)
            if command -v ssl_status >/dev/null 2>&1; then
                ssl_status "$@"
            else
                echo -e "${RED}ERROR: SSL status function not available${NC}" >&2
                exit 1
            fi
            ;;
        generate)
            if command -v ssl_generate_self_signed >/dev/null 2>&1; then
                ssl_generate_self_signed "$@"
            else
                echo -e "${RED}ERROR: SSL generate function not available${NC}" >&2
                exit 1
            fi
            ;;
        setup)
            if command -v ssl_setup >/dev/null 2>&1; then
                ssl_setup "$@"
            else
                echo -e "${RED}ERROR: SSL setup function not available${NC}" >&2
                exit 1
            fi
            ;;
        *)
            echo -e "${YELLOW}Available ssl commands:${NC}"
            echo "  status     - Check SSL certificate status"
            echo "  generate   - Generate self-signed certificate"
            echo "  setup      - Setup SSL certificates"
            ;;
    esac
}

function handle_recovery_command() {
    local subcommand="${1:-help}"
    shift 2>/dev/null || true
    
    case "$subcommand" in
        list|snapshots)
            if [[ -d "${RECOVERY_SNAPSHOT_DIR:-./backups/snapshots}" ]]; then
                echo -e "${BOLD}${CYAN}üì∏ Available System Snapshots${NC}"
                echo "==============================================="
                
                local snapshot_count=0
                while IFS= read -r -d '' snapshot_dir; do
                    ((snapshot_count++))
                    local snapshot_name=$(basename "$snapshot_dir")
                    local metadata_file="$snapshot_dir/metadata.env"
                    
                    if [[ -f "$metadata_file" ]]; then
                        local operation_name timestamp
                        operation_name=$(grep "^OPERATION=" "$metadata_file" 2>/dev/null | cut -d'=' -f2- || echo "Unknown")
                        timestamp=$(grep "^TIMESTAMP=" "$metadata_file" 2>/dev/null | cut -d'=' -f2- || echo "Unknown")
                        
                        echo -e "${GREEN}$snapshot_count.${NC} ${BOLD}$snapshot_name${NC}"
                        echo "   Operation: $operation_name"
                        echo "   Created: $timestamp"
                        echo
                    else
                        echo -e "${YELLOW}$snapshot_count.${NC} $snapshot_name (metadata missing)"
                        echo
                    fi
                done < <(find "${RECOVERY_SNAPSHOT_DIR:-./backups/snapshots}" -maxdepth 1 -type d -name "snapshot_*" -print0 2>/dev/null | sort -z)
                
                if [[ $snapshot_count -eq 0 ]]; then
                    echo "No snapshots found."
                    echo -e "${DIM}Snapshots are created automatically before major operations.${NC}"
                fi
            else
                echo "No snapshots directory found."
            fi
            ;;
        restore)
            local snapshot_id="$1"
            if [[ -z "$snapshot_id" ]]; then
                echo -e "${RED}ERROR: Please specify a snapshot ID${NC}"
                echo "Usage: milou recovery restore <snapshot_id>"
                echo "Use 'milou recovery list' to see available snapshots"
                exit 1
            fi
            
            echo -e "${BOLD}${YELLOW}‚ö†Ô∏è  System Restoration${NC}"
            echo "This will restore your system configuration from snapshot: $snapshot_id"
            echo
            
            if confirm "Are you sure you want to restore from this snapshot?" "N"; then
                restore_system_snapshot "$snapshot_id" "false" "false"
            else
                echo "Restoration cancelled."
            fi
            ;;
        cleanup)
            echo -e "${BOLD}${BLUE}üßπ Cleaning up old snapshots and failed operations${NC}"
            cleanup_old_snapshots "false"
            cleanup_failed_operations "false"
            echo -e "${GREEN}‚úÖ Cleanup completed${NC}"
            ;;
        validate)
            echo -e "${BOLD}${BLUE}üîç Validating system state integrity${NC}"
            if validate_system_state "false"; then
                echo -e "${GREEN}‚úÖ System validation passed${NC}"
            else
                echo -e "${RED}‚ùå System validation failed${NC}"
                echo "Consider running 'milou recovery cleanup' or restoring from a snapshot"
                exit 1
            fi
            ;;
        status)
            echo -e "${BOLD}${CYAN}üìä Recovery System Status${NC}"
            echo "=================================="
            echo
            echo "Recovery enabled: ${RECOVERY_ENABLED:-true}"
            echo "Snapshot directory: ${RECOVERY_SNAPSHOT_DIR:-./backups/snapshots}"
            echo "Max snapshots: ${RECOVERY_MAX_SNAPSHOTS:-10}"
            
            if [[ -d "${RECOVERY_SNAPSHOT_DIR:-./backups/snapshots}" ]]; then
                local snapshot_count
                snapshot_count=$(find "${RECOVERY_SNAPSHOT_DIR:-./backups/snapshots}" -maxdepth 1 -type d -name "snapshot_*" 2>/dev/null | wc -l)
                echo "Current snapshots: $snapshot_count"
            else
                echo "Current snapshots: 0 (directory not created yet)"
            fi
            
            echo
            echo "Current operation: ${RECOVERY_CURRENT_OPERATION:-none}"
            echo "Current snapshot: ${RECOVERY_SNAPSHOT_ID:-none}"
            ;;
        help|*)
            echo -e "${BOLD}${GREEN}Milou Recovery System${NC}"
            echo
            echo -e "${BOLD}Usage:${NC} milou recovery <command> [options]"
            echo
            echo -e "${BOLD}Commands:${NC}"
            echo "  list                            List available snapshots"
            echo "  restore <snapshot_id>           Restore from specific snapshot"
            echo "  cleanup                         Clean up old snapshots and failed operations"
            echo "  validate                        Validate current system state"
            echo "  status                          Show recovery system status"
            echo "  help                            Show this help message"
            echo
            echo -e "${BOLD}Examples:${NC}"
            echo "  milou recovery list             # See all available snapshots"
            echo "  milou recovery restore snapshot_20241215_143022_setup"
            echo "  milou recovery cleanup          # Clean up old files"
            echo "  milou recovery validate         # Check system integrity"
            ;;
    esac
}

# =============================================================================
# MAIN FUNCTION
# =============================================================================

function main() {
    # Load core modules first
    load_core_modules
    
    # Get current state for contextual behavior
    local current_state
    current_state=$(get_current_state "true")  # Quiet mode for main
    
    # Parse global options first
    local args=()
    local has_command=false
    
    # Check if we have any commands
    for arg in "$@"; do
        case $arg in
            setup|status|start|stop|restart|logs|backup|restore|update|self-update|admin|config|user|ssl|health|shell|help|version|update-status|recovery)
                has_command=true
                break
                ;;
        esac
    done
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                if [[ "$has_command" == "false" ]]; then
                    show_smart_header "$current_state"
                    show_contextual_help "$current_state"
                    exit 0
                else
                    args+=("$1")
                    shift
                fi
                ;;
            --version)
                if [[ "$has_command" == "false" ]]; then
                    show_version
                    exit 0
                else
                    args+=("$1")
                    shift
                fi
                ;;
            -v|--verbose)
                VERBOSE=true
                export VERBOSE=true
                shift
                ;;
            -d|--debug)
                DEBUG=true
                export DEBUG=true
                set -x
                shift
                ;;
            -y|--yes|--assume-yes)
                ASSUME_YES=true
                export ASSUME_YES=true
                export INTERACTIVE=false
                shift
                ;;
            -f|--force)
                FORCE=true
                export FORCE=true
                shift
                ;;
            *)
                args+=("$1")
                shift
                ;;
        esac
    done
    
    # Restore the non-global arguments
    set -- "${args[@]}"
    
    # Show contextual header and help for interactive sessions with no command
    if [[ $# -eq 0 ]]; then
        show_smart_header "$current_state"
        show_contextual_help "$current_state"
        exit 0
    fi
    
    # Get command
    local command="$1"
    shift
    
    # Dispatch commands with state awareness
    case "$command" in
        setup)
            # Check for help flag first, before state detection
            if [[ "$*" == *--help* ]] || [[ "$*" == *-h* ]]; then
                source "${SRC_DIR}/_setup.sh" || { echo "Setup module not available"; exit 1; }
                if command -v show_setup_help >/dev/null 2>&1; then
                    show_setup_help
                    exit 0
                else
                    echo "Setup help not available"
                    exit 1
                fi
            fi
            handle_smart_setup "$@"
            ;;
        status)
            handle_smart_status "$@"
            ;;
        version)
            # Load update module for comprehensive version info
            if source "${SRC_DIR}/_update.sh" 2>/dev/null; then
                if command -v handle_version >/dev/null 2>&1; then
                    handle_version
                else
                    show_version
                fi
            else
                show_version
            fi
            ;;
        update-status)
            # Show detailed update information
            source "${SRC_DIR}/_update.sh" || { echo "Update module not available"; exit 1; }
            if command -v handle_update_status >/dev/null 2>&1; then
                handle_update_status "$@"
            else
                echo "Update status function not available"
                exit 1
            fi
            ;;
        start)
            handle_docker_command "start" "$@"
            ;;
        stop)
            handle_docker_command "stop" "$@"
            ;;
        restart)
            handle_docker_command "restart" "$@"
            ;;
        logs)
            handle_docker_command "logs" "$@"
            ;;
        backup)
            handle_backup_command "$@"
            ;;
        restore)
            handle_restore_command "$@"
            ;;
        update)
            handle_update_command "$@"
            ;;
        self-update)
            handle_update_command "$@"
            ;;
        admin)
            handle_admin_command "$@"
            ;;
        config)
            handle_config_command "$@"
            ;;
        user)
            handle_user_command "$@"
            ;;
        ssl)
            handle_ssl_command "$@"
            ;;
        health)
            handle_docker_command "health" "$@"
            ;;
        shell)
            handle_docker_command "shell" "$@"
            ;;
        help)
            show_smart_header "$current_state"
            show_contextual_help "$current_state"
            ;;
        recovery)
            handle_recovery_command "$@"
            ;;
        *)
            echo -e "${RED}ERROR: Unknown command: $command${NC}" >&2
            echo "Current state: $(describe_installation_state "$current_state")"
            echo "Suggested action: $(get_recommended_actions "$current_state")"
            echo
            echo "Run 'milou help' for available commands"
            exit 1
            ;;
    esac
}

# =============================================================================
# ENTRY POINT
# =============================================================================

# Only run main if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi 